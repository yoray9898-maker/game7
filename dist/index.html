<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <title>塔防：元素戰爭 - 穩定修復版</title>
    <style>
        body { display: flex; flex-direction: column; align-items: center; background-color: #2c3e50; color: white; font-family: 'Segoe UI', Arial, sans-serif; margin: 0; overflow: hidden; }
        #game-container { position: relative; margin-top: 10px; }
        canvas { background-color: #ecf0f1; border: 5px solid #34495e; border-radius: 8px; cursor: crosshair; }
        .ui-panel { margin-top: 10px; padding: 10px 20px; background: #34495e; border-radius: 8px; display: flex; gap: 15px; box-shadow: 0 4px 6px rgba(0,0,0,0.3); min-width: 800px; justify-content: space-around; }
        .stat-box { display: flex; flex-direction: column; align-items: center; min-width: 85px; }
        .label { font-size: 0.8em; color: #bdc3c7; margin-bottom: 2px; }
        .stat { font-size: 1.4em; color: #f1c40f; font-weight: bold; }
        .overlay { position: absolute; top: 0; left: 0; width: 610px; height: 410px; background: rgba(44, 62, 80, 0.95); display: flex; flex-direction: column; align-items: center; justify-content: center; border-radius: 8px; z-index: 10; }
        .controls { margin-top: 25px; display: flex; gap: 10px; align-items: center; justify-content: center; }
        .shop-btn { padding: 12px 15px; cursor: pointer; border: 3px solid transparent; border-radius: 10px; color: white; font-weight: bold; transition: all 0.2s ease; font-size: 0.95em; opacity: 0.6; }
        .shop-btn.selected { border-color: #f1c40f !important; transform: translateY(-5px); opacity: 1; }
        .item-btn { background: #e74c3c; padding: 12px 15px; cursor: pointer; border: 2px solid #c0392b; border-radius: 10px; color: white; font-weight: bold; position: relative; }
        .item-btn:disabled { opacity: 0.3; cursor: not-allowed; }
        .item-count { position: absolute; top: -10px; right: -10px; background: #f1c40f; color: #2c3e50; border-radius: 50%; width: 22px; height: 22px; display: flex; align-items: center; justify-content: center; font-size: 12px; border: 2px solid #2c3e50; }
        #upgradeMenu { background: #8e44ad; padding: 10px 20px; border-radius: 8px; display: none; gap: 10px; align-items: center; border: 2px solid #f1c40f; }
        .hidden { display: none !important; }
        .difficulty-container { display: grid; grid-template-columns: 200px 1fr; gap: 15px; width: 500px; }
        .btn-diff { font-size: 1.1em; padding: 15px; color: white; border-radius: 8px; cursor: pointer; }
    </style>
</head>
<body>

    <h1>塔防：元素戰爭</h1>

    <div class="ui-panel">
        <div class="stat-box"><span class="label">金錢</span><span id="money" class="stat">200</span></div>
        <div class="stat-box"><span class="label">生命值</span><span id="health" class="stat">20</span></div>
        <div class="stat-box"><span class="label">目前波次</span><span id="waveDisplay" class="stat">1</span></div>
        <div class="stat-box"><span class="label">剩餘敵人</span><span id="enemyCount" class="stat">0</span></div>
        <div class="stat-box" style="min-width: 250px;"><span class="label">當前狀態</span><span id="difficultyInfo" class="stat" style="font-size: 0.9em; color: #f1c40f;">等待開始...</span></div>
    </div>

    <div id="game-container">
        <div id="start-screen" class="overlay">
            <h2 style="color: #f1c40f;">選擇難度</h2>
            <div class="difficulty-container">
                <button class="btn-diff" style="background:#27ae60" onclick="startGame(1.25, '簡單', 1.0)">簡單</button>
                <div style="font-size:0.9em">基礎難度。</div>
                <button class="btn-diff" style="background:#2980b9" onclick="startGame(1.30, '普通', 1.2)">普通</button>
                <div style="font-size:0.9em">平衡難度。</div>
                <button class="btn-diff" style="background:#c0392b" onclick="startGame(1.40, '困難', 1.4)">困難</button>
                <div style="font-size:0.9em">高難度，BOSS 50% 機率掉核彈。</div>
            </div>
        </div>
        <canvas id="gameCanvas" width="600" height="400"></canvas>
    </div>

    <div class="controls">
        <div id="shop">
            <button class="shop-btn" style="background:#2980b9" id="btn-gun" onclick="selectType('gun')">機槍塔 $50</button>
            <button class="shop-btn" style="background:#3498db" id="btn-ice" onclick="selectType('ice')">寒冰塔 $80</button>
            <button class="shop-btn" style="background:#d35400" id="btn-bomb" onclick="selectType('bomb')">砲擊塔 $120</button>
            <button class="shop-btn" style="background:#f1c40f; color: #2c3e50;" id="btn-summon" onclick="selectType('summon')">召喚塔 $150</button>
            <button class="shop-btn" style="background:#7f8c8d" id="btn-trap" onclick="selectType('trap')">陷阱塔 $150</button>
            <button class="item-btn" id="btn-nuke" onclick="useNuke()" disabled>☢️ 核彈 $500 <div class="item-count" id="nuke-count">0</div></button>
        </div>
        <div id="upgradeMenu">
            <span id="towerInfo" style="font-weight: bold; color: #fff;"></span>
            <button id="upgradeBtn" style="background:#f1c40f; color:#2c3e50" onclick="upgradeSelectedTower()">升級 ($<span id="upgradeCost"></span>)</button>
            <button style="background:#EA0000; color:white" onclick="sellSelectedTower()">賣出</button>
            <button style="background:#bdc3c7; color:#2c3e50" onclick="deselectTower()">關閉</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const tileSize = 40;
        
        let money, health, currentWave, enemiesToSpawn, spawnTimer, selectedTower, gameRunning = false, currentType = 'gun';
        let towers = [], enemies = [], bullets = [], friends = [], traps = [];
        let waveInProgress = false, hpGrowthRate = 1.3, moneyBonus = 1.0, difficultyName = "";
        let nukeCount = 0;

        const pathCoords = [{x:0,y:1},{x:4,y:1},{x:4,y:4},{x:2,y:4},{x:2,y:6},{x:7,y:6},{x:7,y:2},{x:13,y:2},{x:13,y:5},{x:10,y:5},{x:10,y:7},{x:14,y:7}];
        const mapLayoutOrig = [[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,0,0,1,1,1,1,1,1,1,0],[0,0,0,0,1,0,0,1,0,0,0,0,0,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,0,1,0],[0,0,1,0,0,0,0,1,0,0,1,1,1,1,0],[0,0,1,1,1,1,1,1,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,1,1,1,1],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]];
        let currentMap = [];
        let roadTiles = []; // 重要：存放道路方格座標

        function startGame(rate, name, bonus) { 
            hpGrowthRate = rate; difficultyName = name; moneyBonus = bonus;
            money = 200; health = 20; currentWave = 1; nukeCount = 0;
            towers = []; enemies = []; bullets = []; friends = []; traps = [];
            roadTiles = []; 
            for(let y=0; y<10; y++) for(let x=0; x<15; x++) if(mapLayoutOrig[y][x]===1) roadTiles.push({x, y});
            
            gameRunning = true; currentMap = mapLayoutOrig.map(row => [...row]); 
            document.getElementById('start-screen').classList.add('hidden'); 
            updateUI(); selectType('gun'); startNextWave(); gameLoop(); 
        }

        function useNuke() {
            if (nukeCount > 0 && money >= 500) {
                money -= 500; nukeCount--;
                enemies.forEach(e => e.hp *= (e.isBoss ? 0.55 : 0.25));
                ctx.fillStyle = "white"; ctx.fillRect(0,0,600,400); // 閃光
                updateUI();
            }
        }

        function updateUI() {
            document.getElementById('money').innerText = Math.floor(money);
            document.getElementById('health').innerText = health;
            document.getElementById('waveDisplay').innerText = currentWave;
            document.getElementById('enemyCount').innerText = enemies.length + enemiesToSpawn;
            document.getElementById('nuke-count').innerText = nukeCount;
            document.getElementById('btn-nuke').disabled = (nukeCount <= 0 || money < 500);
        }

        function selectType(t) { currentType = t; document.querySelectorAll('.shop-btn').forEach(b => b.classList.remove('selected')); document.getElementById('btn-'+t).classList.add('selected'); }

        function startNextWave() { enemiesToSpawn = (currentWave%5===0)?1:5+Math.floor(currentWave*1.5); spawnTimer = 0; waveInProgress = true; }

        class Enemy {
            constructor(isBoss) {
                this.x = pathCoords[0].x*40; this.y = pathCoords[0].y*40; this.targetIndex = 1; this.isBoss = isBoss;
                this.hp = Math.floor((isBoss?600:25)*Math.pow(hpGrowthRate, currentWave-1));
                this.maxHp = this.hp; this.speed = isBoss?0.6:1.3; this.stun = 0; this.slow = 0;
            }
            update() {
                if(this.stun > 0) { this.stun--; return; }
                let s = this.speed * (this.slow > 0 ? 0.5 : 1);
                if(this.slow > 0) this.slow--;
                let t = pathCoords[this.targetIndex], dx = t.x*40-this.x, dy = t.y*40-this.y, d = Math.sqrt(dx*dx+dy*dy);
                if(d < s) { this.targetIndex++; if(this.targetIndex>=pathCoords.length){ health-=this.isBoss?10:1; this.hp=0; } }
                else { this.x += (dx/d)*s; this.y += (dy/d)*s; }
            }
            draw() {
                ctx.fillStyle = this.isBoss?'#8e44ad':'#c0392b';
                ctx.beginPath(); ctx.arc(this.x+20, this.y+20, this.isBoss?18:10, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#2ecc71'; ctx.fillRect(this.x+5, this.y-5, 30*(this.hp/this.maxHp), 3);
            }
        }

        class Tower {
            constructor(x,y,type) {
                this.x=x; this.y=y; this.type=type; this.level=1; this.cd=0; this.totalSpent=0;
                const c = {gun:[130,15,25,'#2980b9',60,50], ice:[110,8,40,'#3498db',100,80], bomb:[160,55,85,'#d35400',150,120], summon:[0,150,550,'#f1c40f',180,150], trap:[0,25,300,'#7f8c8d',120,150]};
                [this.range, this.dmg, this.cdM, this.color, this.upC, this.totalSpent] = c[type];
            }
            getCost() { return Math.floor(this.upC * Math.pow(1.5, this.level-1)); }
            update() {
                if(this.cd > 0) this.cd--;
                else if(this.type === 'trap') {
                    if(roadTiles.length > 0) {
                        let rt = roadTiles[Math.floor(Math.random()*roadTiles.length)];
                        traps.push({x:rt.x, y:rt.y, dmg:this.dmg, dur: 60 + this.level*20});
                        this.cd = this.cdM;
                    }
                } else if(this.type === 'summon') {
                    friends.push(new Friend(this.dmg)); this.cd = this.cdM;
                } else {
                    let target = enemies.find(e => Math.hypot(e.x+20-(this.x+20), e.y+20-(this.y+20)) < this.range);
                    if(target) { bullets.push({x:this.x+20, y:this.y+20, t:target, dmg:this.dmg, type:this.type}); this.cd = this.cdM; }
                }
            }
            draw() { ctx.fillStyle=this.color; ctx.fillRect(this.x+2,this.y+2,36,36); ctx.fillStyle="white"; ctx.fillText("L"+this.level, this.x+5, this.y+15); }
        }

        class Friend {
            constructor(d) { this.x=pathCoords[pathCoords.length-1].x*40; this.y=pathCoords[pathCoords.length-1].y*40; this.tIdx=pathCoords.length-2; this.dmg=d; }
            update() {
                let t=pathCoords[this.tIdx], dx=t.x*40-this.x, dy=t.y*40-this.y, d=Math.sqrt(dx*dx+dy*dy);
                if(d<2){ this.tIdx--; if(this.tIdx<0) return true; } else { this.x+=(dx/d)*2; this.y+=(dy/d)*2; }
                let e = enemies.find(e => Math.hypot(this.x-e.x, this.y-e.y)<30);
                if(e) { e.hp-=this.dmg; return true; } return false;
            }
            draw() { ctx.fillStyle="#2ecc71"; ctx.beginPath(); ctx.arc(this.x+20, this.y+20, 8, 0, Math.PI*2); ctx.fill(); }
        }

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect(); const gx = Math.floor((e.clientX-rect.left)/40), gy = Math.floor((e.clientY-rect.top)/40);
            const t = towers.find(t=>t.x===gx*40 && t.y===gy*40);
            if(t) { selectedTower=t; document.getElementById('shop').style.display='none'; document.getElementById('upgradeMenu').style.display='flex'; document.getElementById('upgradeCost').innerText=t.getCost(); }
            else if(gx<15 && gy<10 && currentMap[gy][gx]===0) {
                let cost = {gun:50, ice:80, bomb:120, summon:150, trap:150}[currentType];
                if(money>=cost) { money-=cost; towers.push(new Tower(gx*40, gy*40, currentType)); currentMap[gy][gx]=2; updateUI(); }
            }
        });

        function deselectTower() { selectedTower=null; document.getElementById('shop').style.display='flex'; document.getElementById('upgradeMenu').style.display='none'; }
        function upgradeSelectedTower() { if(money>=selectedTower.getCost()){ money-=selectedTower.getCost(); selectedTower.level++; selectedTower.dmg*=1.5; deselectTower(); updateUI(); } }
        function sellSelectedTower() { currentMap[selectedTower.y/40][selectedTower.x/40]=0; money+=25; towers=towers.filter(t=>t!==selectedTower); deselectTower(); updateUI(); }

        function gameLoop() {
            if(!gameRunning) return; ctx.clearRect(0,0,600,400);
            // 繪製地圖
            for(let y=0;y<10;y++) for(let x=0;x<15;x++) { ctx.fillStyle=currentMap[y][x]===1?'#d35400':'#27ae60'; ctx.fillRect(x*40, y*40, 40, 40); }
            
            // 陷阱邏輯：渲染與檢測
            traps.forEach(tr => { ctx.fillStyle="black"; ctx.fillRect(tr.x*40+15, tr.y*40+15, 10, 10); });

            if(waveInProgress) {
                if(enemiesToSpawn>0) { if(++spawnTimer>40){ enemies.push(new Enemy(currentWave%5===0)); enemiesToSpawn--; } }
                else if(enemies.length===0) { waveInProgress=false; currentWave++; traps=[]; setTimeout(startNextWave, 2000); }
            }

            for(let i=enemies.length-1; i>=0; i--) {
                let e = enemies[i]; e.update(); e.draw();
                // 陷阱檢測：使用方格座標快速比對
                let ex = Math.floor((e.x+20)/40), ey = Math.floor((e.y+20)/40);
                for(let j=traps.length-1; j>=0; j--) {
                    if(traps[j].x === ex && traps[j].y === ey) {
                        e.hp -= traps[j].dmg; e.stun = traps[j].dur;
                        traps.splice(j, 1);
                    }
                }
                if(e.hp<=0) { 
                    money += (e.isBoss?400:20)*moneyBonus; 
                    if(e.isBoss && Math.random()<0.5) nukeCount++;
                    enemies.splice(i,1); updateUI(); 
                }
            }

            towers.forEach(t=>t.update()); towers.forEach(t=>t.draw());
            bullets = bullets.filter(b => {
                let dx=b.t.x+20-b.x, dy=b.t.y+20-b.y, dist=Math.sqrt(dx*dx+dy*dy);
                if(dist<10){ b.t.hp-=b.dmg; if(b.type==='ice') b.t.slow=60; return false; }
                b.x+=(dx/dist)*10; b.y+=(dy/dist)*10;
                ctx.fillStyle="yellow"; ctx.beginPath(); ctx.arc(b.x, b.y, 3, 0, Math.PI*2); ctx.fill();
                return true;
            });
            friends = friends.filter(f => { f.draw(); return !f.update(); });

            if(health<=0) { alert("遊戲結束！最高波次："+currentWave); location.reload(); }
            else requestAnimationFrame(gameLoop);
        }
    </script>
</body>
</html>
