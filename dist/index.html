<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <title>元素戰爭：核彈末日</title>
    <style>
        * { -webkit-tap-highlight-color: transparent; outline: none; box-sizing: border-box; }
        body { display: flex; flex-direction: column; align-items: center; background-color: #2c3e50; color: white; font-family: 'Microsoft JhengHei', Arial, sans-serif; margin: 0; padding-top: 15px; overflow: hidden; }
        
        /* 頂部 UI 面板 - 完美還原截圖樣式 */
        .ui-panel { display: flex; justify-content: space-between; background: #34495e; padding: 15px 25px; width: 610px; border-radius: 4px; margin-bottom: 15px; box-shadow: 0 4px 0 rgba(0,0,0,0.2); }
        .stat-box { text-align: center; flex: 1; }
        .label { font-size: 0.85em; color: #bdc3c7; display: block; margin-bottom: 5px; }
        .stat { font-size: 1.2em; font-weight: bold; color: #f1c40f; }

        /* 遊戲容器 */
        #game-container { position: relative; width: 612px; height: 412px; }
        canvas { background-color: #ecf0f1; border: 6px solid #34495e; border-radius: 4px; display: block; touch-action: none; }

        /* 難度選擇介面 - 完美還原截圖樣式 */
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(44, 62, 80, 0.98); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; border-radius: 4px; }
        .btn-diff { width: 300px; padding: 15px; border-radius: 8px; cursor: pointer; border: none; font-weight: bold; color: white; margin-bottom: 12px; display: flex; flex-direction: column; align-items: center; transition: 0.2s; }
        .btn-diff .title { font-size: 1.3em; margin-bottom: 3px; }
        .btn-diff .desc { font-size: 0.75em; opacity: 0.9; font-weight: normal; }

        /* 下方商店按鈕 - 完美還原截圖樣式 */
        .controls { margin-top: 15px; display: flex; justify-content: space-between; width: 610px; background: #34495e; padding: 10px; border-radius: 4px; }
        .shop-btn { flex: 1; margin: 0 4px; padding: 12px 0; cursor: pointer; border: 2px solid transparent; border-radius: 4px; color: white; font-weight: bold; font-size: 0.8em; text-align: center; position: relative; transition: all 0.2s; }
        .shop-btn.selected { border-color: #f1c40f; transform: translateY(-8px); box-shadow: 0 5px 15px rgba(0,0,0,0.3); }

        /* 升級選單 */
        #upgradeMenu { background: #8e44ad; padding: 8px 15px; border-radius: 30px; display: none; gap: 10px; align-items: center; border: 2px solid #f1c40f; margin-top: 15px; width: fit-content; }
        #upgradeMenu button { padding: 4px 12px; border-radius: 12px; border: none; font-weight: bold; cursor: pointer; font-size: 0.85em; }
        
        .hidden { display: none !important; }
    </style>
</head>
<body>

    <div class="ui-panel">
        <div class="stat-box"><span class="label">金錢</span><span id="money" class="stat">200</span></div>
        <div class="stat-box"><span class="label">生命值</span><span id="health" class="stat">20</span></div>
        <div class="stat-box"><span class="label">波次</span><span id="waveDisplay" class="stat">1</span></div>
        <div class="stat-box"><span class="label">難度</span><span id="diffInfo" class="stat">--</span></div>
    </div>

    <div id="game-container">
        <div id="start-screen" class="overlay">
            <h1 style="color:#f1c40f; margin-bottom: 20px;">元素戰爭：核彈末日</h1>
            <button class="btn-diff" style="background:#27ae60" onclick="startGame(1.25, 1.0, '簡單')">
                <span class="title">簡單模式</span>
                <span class="desc">金錢 1.0x / 血量 1.25x</span>
            </button>
            <button class="btn-diff" style="background:#2980b9" onclick="startGame(1.30, 1.2, '普通')">
                <span class="title">普通模式</span>
                <span class="desc">金錢 1.2x / 血量 1.30x</span>
            </button>
            <button class="btn-diff" style="background:#c0392b" onclick="startGame(1.40, 1.4, '困難')">
                <span class="title">困難模式</span>
                <span class="desc">金錢 1.4x / 血量 1.40x / ★BOSS帶控制</span>
            </button>
        </div>
        <canvas id="gameCanvas" width="600" height="400"></canvas>
    </div>

    <div id="upgradeMenu">
        <span id="towerInfo" style="font-weight: bold; color:white;"></span>
        <button style="background:#f1c40f;" onclick="upgradeSelectedTower()">升級 $<span id="upgradeCost"></span></button>
        <button style="background:#EA0000; color:white;" onclick="sellSelectedTower()">賣出</button>
        <button style="background:#bdc3c7;" onclick="deselectTower()">X</button>
    </div>

    <div class="controls">
        <button class="shop-btn" id="btn-gun" style="background:#2980b9" onclick="selectType('gun')">機槍塔 $50</button>
        <button class="shop-btn" id="btn-ice" style="background:#3498db" onclick="selectType('ice')">寒冰塔 $80</button>
        <button class="shop-btn" id="btn-bomb" style="background:#d35400" onclick="selectType('bomb')">砲擊塔 $120</button>
        <button class="shop-btn" id="btn-summon" style="background:#f1c40f; color:#2c3e50" onclick="selectType('summon')">召喚塔 $150</button>
        <button class="shop-btn" id="btn-trap" style="background:#7f8c8d" onclick="selectType('trap')">陷阱塔 $150</button>
        <button class="shop-btn" id="btn-nuke" style="background:#34495e;" onclick="useNuke()">核彈 $500</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let money = 200, health = 20, currentWave = 1, gameRunning = false;
        let towers = [], enemies = [], bullets = [], minions = [], traps = [], currentType = null, selectedTower = null;
        let isPressing = false, previewX = -1, previewY = -1;
        let hpGrowth = 1.3, moneyBonus = 1.0;

        const pathPoints = [{x:0,y:1},{x:4,y:1},{x:4,y:4},{x:2,y:4},{x:2,y:6},{x:7,y:6},{x:7,y:2},{x:13,y:2},{x:13,y:5},{x:10,y:5},{x:10,y:7},{x:14,y:7}];
        const mapLayout = [[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,0,0,1,1,1,1,1,1,1,0],[0,0,0,0,1,0,0,1,0,0,0,0,0,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,0,1,0],[0,0,1,0,0,0,0,1,0,0,1,1,1,1,0],[0,0,1,1,1,1,1,1,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,1,1,1,1],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]];
        const roadCells = [];
        for(let y=0; y<10; y++) for(let x=0; x<15; x++) if(mapLayout[y][x] === 1) roadCells.push({x:x*40, y:y*40});

        const towerProps = { 
            gun:[140,25,18,'#2980b9',50], ice:[110,12,35,'#3498db',80], 
            bomb:[170,60,65,'#d35400',120], summon:[150,150,360,'#f1c40f',150], trap:[150,25,300,'#7f8c8d',150] 
        };

        function startGame(rate, bonus, name) {
            hpGrowth = rate; moneyBonus = bonus;
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('diffInfo').innerText = name;
            gameRunning = true; selectType('gun'); spawnWave(); updateUI(); requestAnimationFrame(gameLoop);
        }

        function updateUI() {
            document.getElementById('money').innerText = Math.floor(money);
            document.getElementById('health').innerText = health;
            document.getElementById('waveDisplay').innerText = currentWave;
        }

        function selectType(t) { 
            currentType = t; deselectTower();
            document.querySelectorAll('.shop-btn').forEach(b => b.classList.remove('selected')); 
            if(t) document.getElementById('btn-' + t).classList.add('selected'); 
        }

        function deselectTower() { selectedTower = null; document.getElementById('upgradeMenu').style.display = 'none'; }

        class Enemy {
            constructor(wave) {
                this.x = pathPoints[0].x*40; this.y = pathPoints[0].y*40; this.tIdx = 1;
                this.maxHp = 100 * Math.pow(hpGrowth, wave-1); this.hp = this.maxHp; 
                this.speed = 1.3; this.isBoss = wave % 5 === 0;
                this.flash = 0; this.isCrit = false; this.freezeTimer = 0;
            }
            update() {
                if(this.flash > 0) this.flash--;
                if(this.freezeTimer > 0) { this.freezeTimer--; return; }
                let target = pathPoints[this.tIdx], dx = target.x*40-this.x, dy = target.y*40-this.y, d = Math.sqrt(dx*dx+dy*dy);
                if(d < this.speed) { this.tIdx++; if(this.tIdx>=pathPoints.length){ health--; this.hp=0; updateUI(); } }
                else { this.x += (dx/d)*this.speed; this.y += (dy/d)*this.speed; }
            }
            draw() {
                ctx.fillStyle = "#000"; ctx.fillRect(this.x+5, this.y-8, 30, 5);
                ctx.fillStyle = "#2ecc71"; ctx.fillRect(this.x+5, this.y-8, 30*(this.hp/this.maxHp), 5);
                ctx.fillStyle = this.flash > 0 ? (this.isCrit ? "#ff0000" : "white") : (this.isBoss ? "#8e44ad" : "#c0392b");
                ctx.beginPath(); ctx.arc(this.x+20, this.y+20, this.isBoss?18:12, 0, Math.PI*2); ctx.fill();
            }
        }

        function spawnWave() {
            let count = 5 + currentWave;
            let timer = setInterval(() => {
                if(!gameRunning) { clearInterval(timer); return; }
                enemies.push(new Enemy(currentWave));
                count--;
                if(count <= 0) clearInterval(timer);
            }, 800);
        }

        function gameLoop() {
            if(!gameRunning) return;
            ctx.clearRect(0,0,600,400);
            for(let y=0;y<10;y++) for(let x=0;x<15;x++){ ctx.fillStyle=mapLayout[y][x]===1?'#d35400':'#27ae60'; ctx.fillRect(x*40, y*40, 40, 40); }

            traps = traps.filter(t => {
                ctx.fillStyle = "rgba(0,0,0,0.5)"; ctx.fillRect(t.x+10, t.y+10, 20, 20);
                let target = enemies.find(e => Math.abs(e.x-t.x)<25 && Math.abs(e.y-t.y)<25);
                if(target) {
                    let dur = (1 + (t.lv-1)*0.5) * 60;
                    target.freezeTimer = target.isBoss ? dur*0.5 : dur;
                    return false;
                }
                return true;
            });

            // 手機預覽核心邏輯：按住顯示範圍
            if(isPressing && currentType && previewX !== -1) {
                ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.arc(previewX*40+20, previewY*40+20, towerProps[currentType][0], 0, Math.PI*2);
                ctx.fillStyle = "rgba(255, 255, 255, 0.2)"; ctx.fill();
                ctx.strokeStyle = "white"; ctx.stroke(); ctx.setLineDash([]);
            }

            if(selectedTower) {
                ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.arc(selectedTower.x+20, selectedTower.y+20, selectedTower.range, 0, Math.PI*2);
                ctx.strokeStyle = "white"; ctx.lineWidth = 2; ctx.stroke(); ctx.setLineDash([]);
            }

            enemies = enemies.filter(e => { e.update(); e.draw(); return e.hp > 0; });
            if(enemies.length === 0 && gameRunning) { currentWave++; spawnWave(); updateUI(); }

            towers.forEach(t => { 
                ctx.fillStyle = t.color; ctx.fillRect(t.x+2, t.y+2, 36, 36); 
                if(--t.cd <= 0) {
                    if(t.type === 'summon') {
                        minions.push({x:t.x+20, y:t.y+20, dmg:t.dmg});
                        t.cd = Math.max(120, 360 - (t.level-1)*60);
                    } else if(t.type === 'trap') {
                        let cell = roadCells[Math.floor(Math.random()*roadCells.length)];
                        traps.push({x:cell.x, y:cell.y, lv:t.level});
                        t.cd = Math.max(150, 300 - (t.level-1)*30);
                    } else {
                        let target = enemies.find(e => Math.hypot(e.x+20-(t.x+20), e.y+20-(t.y+20)) < t.range);
                        if(target) { bullets.push({x:t.x+20, y:t.y+20, target, dmg:t.dmg, tower:t}); t.cd = t.cdMax; }
                    }
                }
            });

            minions = minions.filter(m => {
                let target = enemies[0];
                if(target) {
                    let dx = target.x+20-m.x, dy = target.y+20-m.y, dist = Math.sqrt(dx*dx+dy*dy);
                    m.x += (dx/dist)*3; m.y += (dy/dist)*3;
                    if(dist < 20) { target.hp -= m.dmg; target.flash = 6; return false; }
                } else { m.y -= 2; }
                ctx.fillStyle = "#2ecc71"; ctx.beginPath(); ctx.moveTo(m.x, m.y-8); ctx.lineTo(m.x-6, m.y+6); ctx.lineTo(m.x+6, m.y+6); ctx.fill();
                return m.y > 0;
            });

            bullets = bullets.filter(b => {
                let dx = b.target.x+20-b.x, dy = b.target.y+20-b.y, dist = Math.sqrt(dx*dx+dy*dy);
                if(dist < 15) { // 核心傷害判定修復：放寬判定距離
                    let dmg = b.dmg, crit = false;
                    if (b.tower.type === 'gun' && b.tower.level >= 3) {
                        let chance = Math.min(0.6, 0.2 + (b.tower.level-3)*0.04);
                        if (Math.random() < chance) { dmg *= (1.5 + (b.tower.level-3)*0.1); crit = true; }
                    }
                    b.target.hp -= dmg; b.target.flash = 6; b.target.isCrit = crit; return false; 
                }
                b.x += (dx/dist)*10; b.y += (dy/dist)*10; 
                ctx.fillStyle="#f1c40f"; ctx.beginPath(); ctx.arc(b.x, b.y, 4, 0, Math.PI*2); ctx.fill(); 
                return b.target.hp > 0;
            });

            if(health <= 0) { alert("遊戲結束！"); location.reload(); }
            requestAnimationFrame(gameLoop);
        }

        // 手機與滑鼠通用操作邏輯
        function getCoords(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return {
                x: Math.floor((clientX - rect.left) / (rect.width / 15)),
                y: Math.floor((clientY - rect.top) / (rect.height / 10))
            };
        }

        canvas.onpointerdown = (e) => {
            const pos = getCoords(e);
            const clickedTower = towers.find(t => t.x === pos.x*40 && t.y === pos.y*40);
            if(clickedTower) { 
                selectedTower = clickedTower; document.getElementById('upgradeMenu').style.display='flex'; 
                document.getElementById('towerInfo').innerText="Lv."+clickedTower.level; 
                document.getElementById('upgradeCost').innerText=Math.floor(towerProps[clickedTower.type][4]*Math.pow(1.6, clickedTower.level)); 
            } else {
                deselectTower(); isPressing = true; previewX = pos.x; previewY = pos.y;
            }
        };

        canvas.onpointermove = (e) => { if(isPressing) { const pos = getCoords(e); previewX = pos.x; previewY = pos.y; } };

        canvas.onpointerup = (e) => {
            if(isPressing && currentType && previewX !== -1) {
                if(mapLayout[previewY][previewX] === 0 && money >= towerProps[currentType][4]) {
                    money -= towerProps[currentType][4];
                    towers.push({x:previewX*40, y:previewY*40, type:currentType, level:1, range:towerProps[currentType][0], dmg:towerProps[currentType][1], cd:0, cdMax:towerProps[currentType][2], color:towerProps[currentType][3]});
                    mapLayout[previewY][previewX] = 2; updateUI();
                }
            }
            isPressing = false;
        };

        function useNuke() { if(money >= 500) { money -= 500; enemies.forEach(e => {e.hp *= 0.5; e.flash=10; e.isCrit=true;}); updateUI(); } }
        function upgradeSelectedTower() { 
            let cost = Math.floor(towerProps[selectedTower.type][4]*Math.pow(1.6, selectedTower.level)); 
            if(money>=cost){ money-=cost; selectedTower.level++; selectedTower.dmg *= (selectedTower.type==='summon'?1.75:1.7); selectedTower.range+=15; updateUI(); deselectTower(); } 
        }
        function sellSelectedTower() { towers = towers.filter(t => t !== selectedTower); mapLayout[selectedTower.y/40][selectedTower.x/40]=0; money+=Math.floor(towerProps[selectedTower.type][4]*0.6); updateUI(); deselectTower(); }
    </script>
</body>
</html>
