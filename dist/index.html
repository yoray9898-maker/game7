<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <title>å¡”é˜²ï¼šå…ƒç´ æˆ°çˆ­ - ç¶“å…¸å®Œå…¨ç‰ˆ</title>
    <style>
        body { display: flex; flex-direction: column; align-items: center; background-color: #2c3e50; color: white; font-family: 'Segoe UI', Arial, sans-serif; margin: 0; overflow: hidden; }
        #game-container { position: relative; margin-top: 10px; }
        canvas { background-color: #ecf0f1; border: 5px solid #34495e; border-radius: 8px; cursor: crosshair; }
        
        .ui-panel { margin-top: 10px; padding: 10px 20px; background: #34495e; border-radius: 8px; display: flex; gap: 15px; box-shadow: 0 4px 6px rgba(0,0,0,0.3); min-width: 700px; justify-content: space-around; }
        .stat-box { display: flex; flex-direction: column; align-items: center; min-width: 85px; }
        .label { font-size: 0.8em; color: #bdc3c7; margin-bottom: 2px; }
        .stat { font-size: 1.4em; color: #f1c40f; font-weight: bold; }

        .overlay {
            position: absolute; top: 0; left: 0; width: 610px; height: 410px;
            background: rgba(44, 62, 80, 0.95);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            border-radius: 8px; z-index: 10;
        }

        .controls { margin-top: 15px; display: flex; gap: 10px; align-items: center; flex-wrap: wrap; justify-content: center; }
        .shop-btn { padding: 10px 12px; cursor: pointer; border: 3px solid transparent; border-radius: 8px; color: white; font-weight: bold; transition: 0.2s; font-size: 0.9em; }
        .shop-btn.selected { border-color: #f1c40f; transform: translateY(-3px); box-shadow: 0 4px 8px rgba(0,0,0,0.5); }
        
        #upgradeMenu { background: #8e44ad; padding: 10px 20px; border-radius: 8px; display: none; gap: 10px; align-items: center; border: 2px solid #f1c40f; }
        button { padding: 8px 15px; cursor: pointer; border: none; border-radius: 4px; font-weight: bold; transition: 0.2s; }
        button:hover { opacity: 0.8; transform: scale(1.05); }

        .difficulty-options { display: flex; flex-direction: column; gap: 12px; margin-top: 20px; width: 350px; }
        .btn-diff { font-size: 1em; padding: 12px; color: white; border-radius: 8px; text-align: center; }
        .easy { background: #27ae60; }
        .normal { background: #2980b9; }
        .hard { background: #c0392b; border: 2px solid #f1c40f; }

        .btn-sell { background: #EA0000; color: white; }
        .hidden { display: none !important; }
    </style>
</head>
<body>

    <h1>å¡”é˜²ï¼šå…ƒç´ æˆ°çˆ­</h1>

    <div class="ui-panel">
        <div class="stat-box"><span class="label">é‡‘éŒ¢</span><span id="money" class="stat">200</span></div>
        <div class="stat-box"><span class="label">ç”Ÿå‘½å€¼</span><span id="health" class="stat">20</span></div>
        <div class="stat-box"><span class="label">ç›®å‰æ³¢æ¬¡</span><span id="waveDisplay" class="stat">1</span></div>
        <div class="stat-box"><span class="label">å‰©é¤˜æ•µäºº</span><span id="enemyCount" class="stat">0</span></div>
        <div class="stat-box" style="min-width: 120px;"><span class="label">é›£åº¦/æƒ…å ±</span><span id="difficultyInfo" class="stat" style="font-size: 0.9em; color: #f1c40f;">æœªé¸æ“‡</span></div>
    </div>

    <div id="game-container">
        <div id="start-screen" class="overlay">
            <h2 style="color: #f1c40f;">é¸æ“‡æŒ‘æˆ°é›£åº¦</h2>
            <div class="difficulty-options">
                <button class="btn-diff easy" onclick="startGame(1.25, 'ç°¡å–®')">ç°¡å–®ï¼šæ¯æ³¢æ•µäººè¡€é‡å¢åŠ  25%</button>
                <button class="btn-diff normal" onclick="startGame(1.30, 'æ™®é€š')">æ™®é€šï¼šæ¯æ³¢æ•µäººè¡€é‡å¢åŠ  30%</button>
                <button class="btn-diff hard" onclick="startGame(1.40, 'å›°é›£')">å›°é›£ï¼šæ¯æ³¢æ•µäººè¡€é‡å¢åŠ  40%</button>
            </div>
            <p style="margin-top: 20px; font-size: 0.9em; color: #ecf0f1; background: rgba(192, 57, 43, 0.4); padding: 8px 15px; border-radius: 5px; border-left: 4px solid #c0392b;">
                ğŸ’¡ <b>å›°é›£é›£åº¦é‡‘å¹£ç²å– 1.2 å€ï¼ŒBOSS ç§»é€Ÿå¢åŠ  1.25 å€</b>
            </p>
        </div>

        <div id="game-over-screen" class="overlay hidden">
            <h2 style="color: #EA0000;">æˆ°åœ°å¤±å®ˆ</h2>
            <p id="final-stats" style="font-size: 1.2em; margin-bottom: 20px;"></p>
            <button style="background:#27ae60; color:white; padding: 12px 30px;" onclick="showStartScreen()">è¿”å›ä¸»é¸å–®</button>
        </div>
        <canvas id="gameCanvas" width="600" height="400"></canvas>
    </div>

    <div class="controls">
        <div id="shop">
            <button class="shop-btn selected" style="background:#2980b9" id="btn-gun" onclick="selectType('gun')">æ©Ÿæ§å¡” $50</button>
            <button class="shop-btn" style="background:#3498db" id="btn-ice" onclick="selectType('ice')">å¯’å†°å¡” $80</button>
            <button class="shop-btn" style="background:#d35400" id="btn-bomb" onclick="selectType('bomb')">ç ²æ“Šå¡” $120</button>
            <button class="shop-btn" style="background:#f1c40f; color: #2c3e50;" id="btn-summon" onclick="selectType('summon')">å¬å–šå¡” $150</button>
        </div>
        <div id="upgradeMenu">
            <span id="towerInfo" style="font-weight: bold; color: #fff;"></span>
            <button id="upgradeBtn" style="background:#f1c40f; color:#2c3e50" onclick="upgradeSelectedTower()">å‡ç´š ($<span id="upgradeCost"></span>)</button>
            <button class="btn-sell" onclick="sellSelectedTower()">è³£å‡º ($<span id="sellValue"></span>)</button>
            <button style="background:#bdc3c7; color:#2c3e50" onclick="deselectTower()">å–æ¶ˆ</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const tileSize = 40;
        
        let money, health, currentWave, enemiesToSpawn, spawnTimer, selectedTower, gameRunning, currentType = 'gun';
        let towers = [], enemies = [], bullets = [], friends = [], particles = [];
        let waveInProgress = false;
        let hpGrowthRate = 1.30;
        let difficultyName = "æ™®é€š";

        const path = [{x:0,y:1},{x:4,y:1},{x:4,y:4},{x:2,y:4},{x:2,y:6},{x:7,y:6},{x:7,y:2},{x:13,y:2},{x:13,y:5},{x:10,y:5},{x:10,y:7},{x:14,y:7}];
        const mapLayoutOrig = [[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,0,0,1,1,1,1,1,1,1,0],[0,0,0,0,1,0,0,1,0,0,0,0,0,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,0,1,0],[0,0,1,0,0,0,0,1,0,0,1,1,1,1,0],[0,0,1,1,1,1,1,1,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,1,1,1,1],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]];
        let currentMap = [];

        class Enemy {
            constructor(isBoss = false) {
                this.x = path[0].x * tileSize; this.y = path[0].y * tileSize;
                this.targetIndex = 1; this.isBoss = isBoss;
                const growthFactor = Math.pow(hpGrowthRate, currentWave - 1); 
                this.maxHp = Math.floor((isBoss ? 550 : 25) * growthFactor);
                this.hp = this.maxHp;
                if (difficultyName === "å›°é›£") {
                    this.baseSpeed = isBoss ? (0.5 * 1.25) : (1.3 + Math.random() * 0.8);
                } else {
                    this.baseSpeed = isBoss ? (0.5 * 1.15) : ((1.3 + Math.random() * 0.8) * 0.85);
                }
                this.speed = this.baseSpeed;
                this.slowTimer = 0;
                this.origColor = isBoss ? '#8e44ad' : (this.baseSpeed > 1.5 ? '#e67e22' : '#c0392b');
                this.iceResist = isBoss ? 0.5 : 1.0; 
                this.bombResist = (this.baseSpeed > 1.5) ? 0.7 : 1.0; 
                this.skillTimer = 0;
            }
            update() {
                if(this.slowTimer > 0) { this.slowTimer--; this.speed = this.baseSpeed * (0.4 + (1 - this.iceResist) * 0.4); } 
                else { this.speed = this.baseSpeed; }
                if (this.isBoss) {
                    this.skillTimer++;
                    if (this.skillTimer >= 300) { this.skillTimer = 0; this.castBossSkill(); }
                }
                let target = path[this.targetIndex];
                let dx = target.x * tileSize - this.x, dy = target.y * tileSize - this.y;
                let dist = Math.sqrt(dx*dx + dy*dy);
                if(dist < this.speed) { this.targetIndex++; if(this.targetIndex >= path.length) { health -= this.isBoss ? 10 : 1; this.hp = 0; } }
                else { this.x += (dx/dist) * this.speed; this.y += (dy/dist) * this.speed; }
            }
            castBossSkill() {
                if (towers.length > 0) {
                    const targetTower = towers[Math.floor(Math.random() * towers.length)];
                    targetTower.freezeTimer = 180;
                    for(let i=0; i<20; i++) particles.push(new Particle(targetTower.x+20, targetTower.y+20, '#00fbff'));
                }
            }
            draw() {
                // æ¢å¾©è¡€æ¢é¡¯ç¤º (ç¶ è‰²)
                ctx.fillStyle = '#c0392b'; ctx.fillRect(this.x+5, this.y - 10, 30, 4);
                ctx.fillStyle = this.slowTimer > 0 ? '#3498db' : '#2ecc71';
                ctx.fillRect(this.x+5, this.y - 10, Math.max(0, 30 * (this.hp / this.maxHp)), 4);
                
                ctx.fillStyle = this.origColor;
                ctx.beginPath(); ctx.arc(this.x + 20, this.y + 20, this.isBoss?18:10, 0, Math.PI*2); ctx.fill();
                if(this.isBoss) { 
                    ctx.strokeStyle = "#f1c40f"; ctx.lineWidth = 2; ctx.stroke();
                    ctx.fillStyle = "rgba(0, 251, 255, 0.5)";
                    ctx.fillRect(this.x, this.y + 35, tileSize * (this.skillTimer/300), 3);
                }
            }
        }

        class Tower {
            constructor(x, y, type) {
                this.x = x; this.y = y; this.type = type; this.level = 1; this.cooldown = 0; this.totalSpent = 0;
                this.freezeTimer = 0;
                if(type === 'gun') { this.range=130; this.damage=12; this.cdMax=25; this.color='#2980b9'; this.upgradeBaseCost=60; this.totalSpent=50; }
                if(type === 'ice') { this.range=110; this.damage=5; this.cdMax=40; this.color='#3498db'; this.upgradeBaseCost=100; this.totalSpent=80; }
                if(type === 'bomb') { this.range=160; this.damage=50; this.cdMax=85; this.color='#d35400'; this.upgradeBaseCost=150; this.totalSpent=120; }
                if(type === 'summon') { this.range=0; this.damage=75; this.cdMax=550; this.color='#f1c40f'; this.upgradeBaseCost=180; this.totalSpent=150; }
            }
            getUpgradeCost() { return Math.floor(this.upgradeBaseCost * Math.pow(1.6, this.level - 1)); }
            getSellValue() { return Math.floor(this.totalSpent * 0.5); }
            upgrade() {
                let cost = this.getUpgradeCost(); this.totalSpent += cost; this.level++; 
                if (this.type === 'summon') { this.damage = Math.floor(this.damage * 1.75); this.cdMax = Math.max(220, Math.floor(this.cdMax * 0.8)); }
                else { this.range += 12; this.damage = Math.floor(this.damage * 1.7); this.cdMax = Math.max(8, Math.floor(this.cdMax * 0.85)); }
            }
            update() {
                if(this.freezeTimer > 0) { this.freezeTimer--; return; }
                if(this.cooldown > 0) this.cooldown--;
                if(this.cooldown <= 0) {
                    if (this.type === 'summon') { friends.push(new Friend(this.damage, this.level)); this.cooldown = this.cdMax; }
                    else {
                        const target = enemies.find(e => Math.hypot((e.x+20)-(this.x+20), (e.y+20)-(this.y+20)) < this.range);
                        if(target) { bullets.push(new Bullet(this.x+20, this.y+20, target, this.damage, this.type)); this.cooldown = this.cdMax; }
                    }
                }
            }
            draw() {
                if (selectedTower === this && this.range > 0) {
                    ctx.beginPath(); ctx.arc(this.x + 20, this.y + 20, this.range, 0, Math.PI * 2);
                    ctx.fillStyle = "rgba(255, 255, 255, 0.1)"; ctx.fill();
                    ctx.setLineDash([5, 5]); ctx.strokeStyle = "rgba(255, 255, 255, 0.4)";
                    ctx.lineWidth = 2; ctx.stroke(); ctx.setLineDash([]);
                }
                ctx.fillStyle = this.color; ctx.fillRect(this.x+4, this.y+4, tileSize-8, tileSize-8);
                if(this.freezeTimer > 0) {
                    ctx.fillStyle = "rgba(0, 251, 255, 0.4)"; ctx.fillRect(this.x+2, this.y+2, tileSize-4, tileSize-4);
                    ctx.strokeStyle = "#00fbff"; ctx.lineWidth = 2; ctx.strokeRect(this.x+2, this.y+2, tileSize-4, tileSize-4);
                }
                // ä¿®æ­£ç­‰ç´šé¡¯ç¤ºç‚º Lv.æ•¸å­—
                ctx.fillStyle = this.type === 'summon' ? "#2c3e50" : "white"; 
                ctx.font = "bold 11px Arial"; ctx.fillText("Lv."+this.level, this.x+6, this.y+17);
            }
        }

        class Particle { constructor(x, y, color) { this.x = x; this.y = y; this.vx = (Math.random() - 0.5) * 4; this.vy = (Math.random() - 0.5) * 4; this.life = 25; this.color = color; } update() { this.x += this.vx; this.y += this.vy; this.life--; } draw() { ctx.save(); ctx.globalAlpha = this.life / 25; ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, 3, 3); ctx.restore(); } }
        class Friend { constructor(damage, level) { this.targetIndex = path.length - 2; this.x = path[path.length - 1].x * tileSize; this.y = path[path.length - 1].y * tileSize; this.speed = 2.2; this.damage = damage; this.radius = 8 + (level - 1) * 2; } update() { let target = path[this.targetIndex]; let dx = target.x * tileSize - this.x, dy = target.y * tileSize - this.y; let dist = Math.sqrt(dx * dx + dy * dy); if (dist < this.speed) { this.targetIndex--; if (this.targetIndex < 0) return true; } else { this.x += (dx / dist) * this.speed; this.y += (dy / dist) * this.speed; } for (let e of enemies) { if (Math.hypot(this.x + 20 - (e.x + 20), this.y + 20 - (e.y + 20)) < 25) { e.hp -= this.damage * (e.isBoss ? 0.8 : 1); for(let i=0; i<15; i++) particles.push(new Particle(this.x+20, this.y+20, '#2ecc71')); return true; } } return false; } draw() { ctx.fillStyle = '#2ecc71'; ctx.beginPath(); ctx.arc(this.x + 20, this.y + 20, this.radius, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = "#eafff2"; ctx.beginPath(); ctx.arc(this.x + 18, this.y + 18, this.radius/3, 0, Math.PI * 2); ctx.fill(); } }
        class Bullet { constructor(x, y, target, damage, type) { this.x = x; this.y = y; this.target = target; this.damage = damage; this.type = type; } update() { let dx = this.target.x+20 - this.x, dy = this.target.y+20 - this.y; let dist = Math.sqrt(dx*dx + dy*dy); if(dist < 8) { if(this.type === 'ice') this.target.slowTimer = 60; if(this.type === 'bomb') { enemies.forEach(e => { if(Math.hypot(e.x - this.target.x, e.y - this.target.y) < 75) e.hp -= this.damage * e.bombResist; }); } else { this.target.hp -= this.damage; } return true; } this.x += (dx/dist) * 14; this.y += (dy/dist) * 14; return false; } draw() { ctx.fillStyle = this.type === 'ice' ? '#00fbff' : (this.type === 'bomb' ? '#ff6600' : '#f1c40f'); ctx.beginPath(); ctx.arc(this.x, this.y, this.type==='bomb'?6:3, 0, Math.PI*2); ctx.fill(); } }

        function showStartScreen() { gameRunning = false; document.getElementById('start-screen').classList.remove('hidden'); document.getElementById('game-over-screen').classList.add('hidden'); }
        function startGame(rate, name) { hpGrowthRate = rate; difficultyName = name; money = 200; health = 20; currentWave = 1; towers = []; enemies = []; bullets = []; friends = []; particles = []; gameRunning = true; waveInProgress = false; currentMap = mapLayoutOrig.map(row => [...row]); document.getElementById('start-screen').classList.add('hidden'); document.getElementById('difficultyInfo').innerText = difficultyName; startNextWave(); gameLoop(); }
        function startNextWave() { enemiesToSpawn = (currentWave % 5 === 0) ? 1 : 5 + Math.floor(currentWave * 1.5); spawnTimer = 0; waveInProgress = true; }

        canvas.addEventListener('mousedown', (e) => { 
            if(!gameRunning) return; 
            const rect = canvas.getBoundingClientRect(); 
            const gx = Math.floor((e.clientX - rect.left) / tileSize), gy = Math.floor((e.clientY - rect.top) / tileSize); 
            if(gy < 0 || gy >= 10 || gx < 0 || gx >= 15) return; 
            const t = towers.find(t => t.x === gx*tileSize && t.y === gy*tileSize); 
            if(t) { showUpgrade(t); return; } 
            const costs = {gun:50, ice:80, bomb:120, summon:150}; 
            if(currentMap[gy][gx] === 0 && money >= costs[currentType]) { 
                money -= costs[currentType]; towers.push(new Tower(gx*tileSize, gy*tileSize, currentType)); 
                currentMap[gy][gx] = 2; deselectTower(); 
            } else { deselectTower(); } 
        });
        function showUpgrade(t) { selectedTower = t; document.getElementById('shop').style.display = 'none'; document.getElementById('upgradeMenu').style.display = 'flex'; document.getElementById('towerInfo').innerText = `Lv.${t.level}`; document.getElementById('upgradeCost').innerText = t.getUpgradeCost(); document.getElementById('sellValue').innerText = t.getSellValue(); }
        function deselectTower() { selectedTower = null; document.getElementById('shop').style.display = 'block'; document.getElementById('upgradeMenu').style.display = 'none'; }
        function upgradeSelectedTower() { const cost = selectedTower.getUpgradeCost(); if(money >= cost) { money -= cost; selectedTower.upgrade(); showUpgrade(selectedTower); } }
        function sellSelectedTower() { if(!selectedTower) return; money += selectedTower.getSellValue(); currentMap[selectedTower.y / tileSize][selectedTower.x / tileSize] = 0; towers = towers.filter(t => t !== selectedTower); deselectTower(); }
        function selectType(t) { currentType = t; document.querySelectorAll('.shop-btn').forEach(b => b.classList.remove('selected')); document.getElementById('btn-' + t).classList.add('selected'); }
        function updateUI() { document.getElementById('money').innerText = Math.floor(money); document.getElementById('health').innerText = Math.floor(health); document.getElementById('waveDisplay').innerText = (currentWave % 5 === 0) ? `${currentWave} (BOSS)` : currentWave; const totalRemaining = enemiesToSpawn + enemies.length; document.getElementById('enemyCount').innerText = totalRemaining; }

        function gameLoop() {
            if(!gameRunning) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for(let y=0; y<10; y++) for(let x=0; x<15; x++) { ctx.fillStyle = currentMap[y][x] === 1 ? '#d35400' : '#27ae60'; ctx.fillRect(x*tileSize, y*tileSize, tileSize, tileSize); }
            if(waveInProgress) { if(enemiesToSpawn > 0) { if(++spawnTimer > (currentWave % 5 === 0 ? 120 : 40)) { enemies.push(new Enemy(currentWave % 5 === 0)); enemiesToSpawn--; spawnTimer = 0; } } else if(enemies.length === 0) { waveInProgress = false; setTimeout(() => { if(gameRunning) { currentWave++; startNextWave(); } }, 2000); } }
            updateUI(); 
            for (let i = friends.length - 1; i >= 0; i--) { if (friends[i].update()) friends.splice(i, 1); else friends[i].draw(); }
            for(let i=enemies.length-1; i>=0; i--) { enemies[i].update(); enemies[i].draw(); if(enemies[i].hp <= 0) { let reward = enemies[i].isBoss ? (250 + currentWave * 30) : (18 + currentWave); if(hpGrowthRate >= 1.4) reward *= 1.2; money += reward; enemies.splice(i, 1); } }
            towers.forEach(t => { t.update(); t.draw(); });
            for(let i=bullets.length-1; i>=0; i--) { if(bullets[i].update()) bullets.splice(i,1); else bullets[i].draw(); }
            for(let i=particles.length-1; i>=0; i--) { particles[i].update(); if(particles[i].life <= 0) particles.splice(i,1); else particles[i].draw(); }
            if(health <= 0) { gameRunning = false; document.getElementById('game-over-screen').classList.remove('hidden'); document.getElementById('final-stats').innerText = `æœ€é«˜æ³¢æ¬¡ï¼š${currentWave}`; }
            else requestAnimationFrame(gameLoop);
 
